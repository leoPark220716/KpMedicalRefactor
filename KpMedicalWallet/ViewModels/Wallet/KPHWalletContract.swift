//
//  KPHWalletContract.swift
//  KpMedicalWallet
//
//  Created by Junsung Park on 9/23/24.
//

import Foundation
import CryptoSwift
import web3swift
import Web3Core
import Security
import CryptoKit
import BigInt
class KPHWalletContract: WalletHttpRequest{
    // ÏßÄÍ∞ë Î≥µÍµ¨
    func recoverWallet(password: String) throws -> String{
        do {
            guard let keystore = try BIP32Keystore(mnemonics: Mnemonicse, password: password) else {
                print("‚ùå keystore ")
                throw TraceUserError.clientError("recoverWallet keystore")
            }
            //            keystore ÏßÅÎ†¨Ìôî
            guard let keystoreData = try keystore.serialize()else{
                print("‚ùå keystoreData")
                throw TraceUserError.clientError("recoverWallet keystoreData")
            }
            //            ÏßÅÎ†¨Ìôî keystore keychain Ïóê Ï†ÄÏû•
            let saveStatus = saveToKeyChain(keystoreData: keystoreData, account: UserAccount)
            if saveStatus != errSecSuccess {
                print("‚ùå saveToKeyChain \(saveStatus)")
                throw TraceUserError.clientError("recoverWallet saveStatus")
            }
            // Î≥µÍµ¨Îêú Í≥ÑÏ†ïÏùò Ï≤´ Î≤àÏß∏ Ï£ºÏÜåÎ•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
            guard let address = keystore.addresses?.first else {
                throw TraceUserError.clientError("recoverWallet address")
            }
            return address.address
        } catch {
            throw error
        }
    }
    // ÏßÄÍ∞ë ÏÉùÏÑ±
    func generateWallet() throws -> (success: Bool,privateKey: String, WalletPublicKey: String) {
        guard !Mnemonicse.isEmpty else {
            print("ÎãàÎ™®Îãâ ÎπàÎ∞∞Ïó¥")
            throw TraceUserError.clientError("generateWallet Mnemonicse")
        }
        do {
            //            keystore ÏÉùÏÑ±.
            guard let keystore = try BIP32Keystore(mnemonics: Mnemonicse, password: password) else {
                print("keystore ÏÉùÏÑ± Ïã§Ìå®")
                throw TraceUserError.clientError("generateWallet keystore")
            }
            // ÏÉàÎ°úÏö¥ Í≥ÑÏ†ïÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
            try keystore.createNewChildAccount(password: password)
            //            keystore ÏßÅÎ†¨Ìôî
            guard let keystoreData = try keystore.serialize()else{
                print("ÏßÅÎ†¨Ìôî Ïã§Ìå®")
                throw TraceUserError.clientError("generateWallet keysotredata")
            }
            //            ÏßÅÎ†¨Ìôî keystore keychain Ïóê Ï†ÄÏû•
            let saveStatus = saveToKeyChain(keystoreData: keystoreData, account: UserAccount)
            if saveStatus != errSecSuccess {
                print("ÏßÅÎ†¨Ìôî??? \(saveStatus)")
                throw TraceUserError.clientError("generateWallet saveStatus")
            }
            // Ï≤´ Î≤àÏß∏ Ï£ºÏÜåÎ•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
            if let address = keystore.addresses?.first {
                let privateKeyData = try keystore.UNSAFE_getPrivateKeyData(password: password, account: address)
                let privateKeyHexString = privateKeyData.toHexString()
                self.keystore = keystore
                self.keystoreData = keystoreData
                if self.keystore == nil || self.keystoreData == nil{
                    print("‚ùå ÏßÄÍ∞ë ÏÉùÏÑ± Í≥ºÏ†ï Îç∞Ïù¥ÌÑ∞ Í∞ùÏ≤¥ Ìï†Îãπ Ïã§Ìå®")
                    throw TraceUserError.clientError("generateWallet keystoreaddress")
                }
                
                return (true,privateKeyHexString,address.address)
            } else {
                print("ÏßÄÍ∞ë Ï£ºÏÜå Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®")
                throw TraceUserError.clientError("generateWallet else")
            }
        } catch {
            print("ÏßÄÍ∞ëÏÉùÏÑ± ÏóêÎü¨ \(error)")
            throw TraceUserError.clientError(error.localizedDescription)
        }
    }
    // Ïä§ÎßàÌä∏Ïª®Ìä∏ÎûôÌä∏ Î∞∞Ìè¨
    func SmartContractDeploy(contractPara: String) async throws -> (success: Bool, ContractAddress: String){
        do{
            let web3Datas = try returnWeb3Datas()
            if web3Datas{
                guard let bytecodeData = Data.fromHex(sol!) else {
                    print("Î∞îÏù¥Ìä∏ÏΩîÎìú Î¨∏ÏûêÏó¥ÏùÑ DataÎ°ú Î≥ÄÌôòÌï† Ïàò ÏóÜÏäµÎãàÎã§.")
                    return (false, "")
                }
                //            Î∞∞Ìè¨Ìï† Ïª®Ìä∏ÎûôÌä∏ Í∞ùÏ≤¥ ÏÉùÏÑ±
                let contract = Web3.Contract(web3: web3!, abiString: abi!, at: accountAddress, abiVersion: 2)
                //             Î∞∞Ìè¨ ÏòµÏÖò ÏÑ§Ï†ï
                let deployOption = contract?.prepareDeploy(bytecode: bytecodeData, constructor: contract?.contract.constructor, parameters: [contractPara])
                //            Ìä∏ÎûúÏû≠ÏÖò ÏÑ§Ï†ï
                let gas = try await returnGasNonce()
                print("Í≥µÍ∞úÌÇ§")
                print(accountAddress!.address)
                print("Ïó¨Í∏∞ÍπåÏßÄ")
                deployOption?.transaction.nonce = gas.nonce
                deployOption?.transaction.chainID = ChainID
                deployOption?.transaction.to = .contractDeploymentAddress()
                deployOption?.transaction.from = accountAddress
                deployOption?.transaction.gasPrice = gas.gas
                if let result = try await deployOption?.writeToChain(password: password, sendRaw: true){
                    print("Transaction Ï†ÑÏÜ° ÏÑ±Í≥µ \(result.hash)")
                    guard let resultData = Data.fromHex(result.hash) else{
                        throw TraceUserError.clientError("SmartContractDeploy reusltData")
                    }
                    print("‚úÖ Tx Hash \(result.hash)")
                    if let receipt = try await getTransactionReceipt( transactionHash: resultData),
                       let contractAddress = receipt.contractAddress?.address {
                        print("Ìä∏ÎûúÏû≠ÏÖò Î°úÍ∑∏: \(String(describing: receipt.logs))")
                        print("Ìä∏ÎûúÏû≠ÏÖò Ï£ºÏÜå: \(contractAddress)")
                        return (true, contractAddress)
                    } else {
                        print("‚ùåÏò¨Î∞îÎ•∏ Ìä∏ÎûúÏû≠ÏÖò ÏòÅÏàòÏ¶ù ÎòêÎäî Í≥ÑÏïΩ Ï£ºÏÜåÎ•º Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.")
                        throw TraceUserError.clientError("SmartContractDeploy resultData else")
                    }
                }else{
                    print("Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìñâ Ïã§Ìå®")
                    throw TraceUserError.clientError("SmartContractDeploy else")
                }
            }
            else{
                throw TraceUserError.clientError("SmartContractDeploy else")
            }
        }catch{
            print("Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå® ÏóêÎü¨: \(error.localizedDescription)")
            throw TraceUserError.clientError("")
        }
    }
    private func reciptCheck(result: TransactionSendingResult) async throws ->(success:Bool,txHash: String){
        guard let resultData = Data.fromHex(result.hash) else{
            print("‚úÖ\(result.hash)")
            return (success: false, txHash: result.hash)
        }
        guard let receipt = try await getTransactionReceipt(transactionHash: resultData) else{
            print("‚úÖ\(result.hash)")
            return (success: false, txHash: result.hash)
        }
        print("üëÄ \(receipt)")
        if let firstLog = receipt.logs.first{
            let hexString = firstLog.data.toHexString()
            if let hexValue = BigUInt(hexString, radix: 16) {
                print("‚úÖ Tx receipt Log : \(firstLog)")
                let decimalValue = String(hexValue)
                if decimalValue == "1"{
                    return (success: true, txHash: result.hash)
                }else{
                    return (success: false, txHash: result.hash)
                }
            }
        }
        print("‚ùå reciptCheck")
        return (success: false, txHash: result.hash)
    }
    
    // Ïä§ÎßàÌä∏Ïª®Ìä∏ÎûôÌä∏ ÏûëÏÑ± (Ï†ÄÏû• ÏàòÎùΩ)
    func callConfirmSaveRecode(privateKey: Data,hospitalID: UInt32,date: BigUInt,password: String,contractAddress: String)  async throws -> (success:Bool,txHash: String) {
        do{
            print("Start callConfirmSaveRecode")
            guard let web3 = web3 else {
                print("‚ùåcallConfirmSaveRecode web3")
                throw TraceUserError.clientError("")
            }
            guard let abi = abi else {
                print("‚ùåcallConfirmSaveRecode abi")
                throw TraceUserError.clientError("")
            }
            guard let accountAddress = accountAddress else{
                print("‚ùåcallConfirmSaveRecode accountAddress")
                throw TraceUserError.clientError("")
            }
            let contract = Web3.Contract(web3: web3, abiString: abi, at: EthereumAddress(contractAddress), abiVersion: 2)
            guard let trasaction = contract?.createWriteOperation(
                "confirmSaveRecord",
                parameters: [hospitalID,date] as [AnyObject],
                extraData: Data()
            )else{
                print("‚ùåcallConfirmSaveRecode contract?.createWriteOperation")
                throw TraceUserError.clientError("")
            }
            let gasNonce = try await returnGasNonce()
            print("üëÄ gas : \(gasNonce.gas)")
            print("üëÄ nonce : \(gasNonce.nonce)")
            trasaction.transaction.nonce = gasNonce.nonce
            trasaction.transaction.from = accountAddress
            trasaction.transaction.chainID = ChainID
            trasaction.transaction.gasPrice = gasNonce.gas
            let estimatedGasLimit = try await web3.eth.estimateGas(for: trasaction.transaction, onBlock: .pending)
            trasaction.transaction.gasLimit = estimatedGasLimit
            try trasaction.transaction.sign(privateKey: privateKey)
            let result = try await trasaction.writeToChain(password: password,sendRaw: true)
            let returnVal = try await reciptCheck(result: result)
            return returnVal
        }catch let error as TraceUserError{
            throw error
        }catch let error as Web3Error{
            print("‚ùåWeb3Error")
            print(error.errorDescription as Any)
            return (success: false, txHash: "result.hash")
        }catch{
            print("‚ùå error")
            return (success: false, txHash: "result.hash")
        }
    }
    
    
    
    
    
    //    Ïä§ÎßàÌä∏ Ïª®Ìä∏ÎûôÌä∏ ÏàòÏ†ï ÏàòÎùΩ
    func callConfirmEditRecord(key: Data, contractAddress: String, hospitalID: UInt32, date: BigUInt,password: String,index: BigUInt) async -> (success:Bool,txHash: String) {
        print( "üí∂ HospitalID \(hospitalID)")
        print( "üí∂ unixTime \(date)")
        guard let keystoreData = loadFromKeychain(account: UserAccount) else {
            print("Failed to load keystore")
            return (false,"")
        }
        
        if providerURL == nil{
            return (false, "")
        }
        guard let keystore = BIP32Keystore(keystoreData) else {
            print("keystore ÏÉùÏÑ± Ïã§Ìå®")
            return (false,"")
        }
        let keystoreManager = KeystoreManager([keystore])
        
        do {
            let provider = try await Web3HttpProvider(url: providerURL!, network: .Custom(networkID: ChainID), keystoreManager: keystoreManager)
            let web3 = Web3(provider: provider)
            
            // keystore Ïóê ÏûàÎäî Í≥ÑÏ†ï Ï£ºÏÜå ÎΩëÏïÑÏò¥
            guard let accountAddress = keystore.addresses?.first else {
                print("Í≥ÑÏ†ï Ï£ºÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
                return (false,"")
            }
            print("üëÄ \(accountAddress.address)")
            print("üëÄ \(contractAddress)")
            // abi Í∞í Ï∂îÏ∂ú
            guard let abiUrl = Bundle.main.url(forResource: "PersonalRecords_sol_PersonalRecords", withExtension: "json"),
                  let abiString = try? String(contentsOf: abiUrl) else {
                print("ABI ÌååÏùº Ïã§Ìå®")
                return (false,"")
            }
            let contract = Web3.Contract(web3: web3, abiString: abiString, at: EthereumAddress(contractAddress), abiVersion: 2)
            print("Create Contract")
            // Ìï®Ïàò Ìò∏Ï∂ú Ìä∏ÎûúÏû≠ÏÖò ÏÉùÏÑ±
            guard let transaction = contract?.createWriteOperation(
                "confirmEditRecord",
                parameters: [index,hospitalID,date] as [AnyObject],
                extraData: Data()
            ) else {
                print("Ìä∏ÎûúÏû≠ÏÖò ÏÉùÏÑ± Ïã§Ìå®")
                return (false,"")
            }
            print("Create Transaction")
            let maxGasPrice = BigUInt(50) * BigUInt(10).power(9) // Ïòà: 50 Gwei
            let gasPrice = try await web3.eth.gasPrice()
            print("Current gas price (\(gasPrice)) exceeds the configured max gas price (\(maxGasPrice))")
            
            guard gasPrice <= maxGasPrice else {
                print("Current gas price (\(gasPrice)) exceeds the configured max gas price (\(maxGasPrice))")
                return (false,"")
            }
            print("Create Nonce")
            // Ìä∏ÎûúÏû≠ÏÖò ÏÑ§Ï†ï
            let currentNonce = try await web3.eth.getTransactionCount(for: accountAddress, onBlock: .latest)
            let increasedGasPrice = gasPrice * 120 / 100

            print("Current nonce: \(currentNonce)")
            transaction.transaction.nonce = currentNonce
            transaction.transaction.from = accountAddress
            transaction.transaction.chainID = ChainID
            transaction.transaction.gasPrice = increasedGasPrice
            print("Current gas price (\(gasPrice)) exceeds the configured max gas price (\(maxGasPrice))")
            let estimatedGasLimit = try await web3.eth.estimateGas(for: transaction.transaction, onBlock: .latest)
            transaction.transaction.gasLimit = estimatedGasLimit
            try! transaction.transaction.sign(privateKey: key)
            let result = try await transaction.writeToChain(password: password, sendRaw: true)
            guard let resultData = Data.fromHex(result.hash) else {
                return (false,"")
            }
            print("Current gas price (\(gasPrice)) exceeds the configured max gas price (\(estimatedGasLimit))")
            do{
                print("Transaction Hash")
                print(result.hash)
                if let receipt = try await getTransactionReceipt(web3: web3, transactionHash: resultData){
                    print("Ìä∏ÎûúÏû≠ÏÖò Î°úÍ∑∏: \(String(describing: receipt.logs))")
                    print("Ìä∏ÎûúÏû≠ÏÖò Î°úÍ∑∏: \(String(describing: receipt.logs[0].data))")
                    if let firstLog = receipt.logs.first {
                        print("Address: \(firstLog.address.address)")
                        print("Block Hash: \(firstLog.blockHash.toHexString())")
                        print("Block Number: \(firstLog.blockNumber)")
                        print("Data: \(firstLog.data.toHexString())")
                        let hexString = firstLog.data.toHexString()
                        if let hexValue = BigUInt(hexString, radix: 16) {
                            let decimalValue = String(hexValue)
                            print("16ÏßÑÏàò Í∞í: \(hexString)")
                            print("10ÏßÑÏàò Í∞í: \(decimalValue)")
                        } else {
                            print("ÏûòÎ™ªÎêú 16ÏßÑÏàò Í∞í")
                        }
                        print("Log Index: \(firstLog.logIndex)")
                        print("Removed: \(firstLog.removed)")
                        print("Topics: \(firstLog.topics.map { $0.toHexString()})")
                        print("Transaction Hash: \(firstLog.transactionHash.toHexString())")
                        print("Transaction Index: \(firstLog.transactionIndex)")
                    }
                    return (true,result.hash)
                }else{
                    print("Î†àÏãúÌîºÎ•º Î∞õÏßÄ Î™ªÌï®")
                    return (false,"")
                }
            }
            catch{
                print("receipt \(error.localizedDescription)")
                return (false,"")
            }
        } catch {
            print("Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå® ÏóêÎü¨: \(error.localizedDescription)")
            return (false,"")
        }
    }
    // Ïä§ÎßàÌä∏Ïª®Ìä∏ÎûôÌä∏ ÏûëÏÑ± (Í≥µÏú† ÏàòÎùΩ)
    func callConfirmShaerRecode(privateKey: Data, param: [SharedData],password: String,contractAddress: String,nonce: BigUInt)  async throws -> (success:Bool,txHash: String) {
        do{
            print("Start callConfirmShaerRecode")
            guard let web3 = web3 else {
                print("‚ùåcallConfirmSaveRecode web3")
                throw TraceUserError.clientError("")
            }
            guard let abi = abi else {
                print("‚ùåcallConfirmSaveRecode abi")
                throw TraceUserError.clientError("")
            }
            guard let accountAddress = accountAddress else{
                print("‚ùåcallConfirmSaveRecode accountAddress")
                throw TraceUserError.clientError("")
            }
            let paramArray: [[AnyObject]] = param.map { sharedData in
                print("üëÄ Check callCOnfirmShaerParam \(param)")
                return [sharedData.index, sharedData.hospital_id, sharedData.hospital_key] as [AnyObject]
            }
            let contract = Web3.Contract(web3: web3, abiString: abi, at: EthereumAddress(contractAddress), abiVersion: 2)
            guard let trasaction = contract?.createWriteOperation(
                "setRecordToShare",
                parameters: [paramArray] as [AnyObject],
                extraData: Data()
            )else{
                print("‚ùåcallConfirmSaveRecode contract?.createWriteOperation")
                throw TraceUserError.clientError("")
            }
            let gasNonce = try await returnGasNonce()
            trasaction.transaction.nonce = gasNonce.nonce+1
            trasaction.transaction.from = accountAddress
            trasaction.transaction.chainID = ChainID
            trasaction.transaction.gasPrice = gasNonce.gas * BigUInt(1.2)
            let estimatedGasLimit = try await web3.eth.estimateGas(for: trasaction.transaction, onBlock: .pending)
            trasaction.transaction.gasLimit = estimatedGasLimit
            try trasaction.transaction.sign(privateKey: privateKey)
            let result = try await trasaction.writeToChain(password: password,sendRaw: true)
            let returnVal = try await reciptCheck(result: result)
            return returnVal
        }catch let error as TraceUserError{
            throw error
        }catch let error as Web3Error{
            print("‚ùåcallConfirmShaerRecode Web3Error")
            print(error.errorDescription as Any)
            return (success: false, txHash: "result.hash")
        }catch{
            print("‚ùåcallConfirmShaerRecode error")
            return (success: false, txHash: "result.hash")
        }
    }
    
    
    // Ïä§ÎßàÌä∏Ïª®Ìä∏ÎûôÌä∏ ÏùΩÍ∏∞ ()
    func callConfirmReadRecode(privateKey: Data,param1: BigUInt?, param2: BigUInt?,methodName: String,password: String,contractAddress: String)  async throws -> (success:Bool,result: [String: Any],nonce: BigUInt) {
        do{
            print("Start callConfirmSaveRecode")
            guard let web3 = web3 else {
                print("‚ùåcallConfirmSaveRecode web3")
                throw TraceUserError.clientError("")
            }
            guard let abi = abi else {
                print("‚ùåcallConfirmSaveRecode abi")
                throw TraceUserError.clientError("")
            }
            guard let accountAddress = accountAddress else{
                print("‚ùåcallConfirmSaveRecode accountAddress")
                throw TraceUserError.clientError("")
            }
            let contract = Web3.Contract(web3: web3, abiString: abi, at: EthereumAddress(contractAddress), abiVersion: 2)
            guard let trasaction = contract?.createWriteOperation(
                methodName,
                parameters: [param1,param2] as [AnyObject],
                extraData: Data()
            )else{
                print("‚ùåcallConfirmSaveRecode contract?.createWriteOperation")
                throw TraceUserError.clientError("")
            }
            let gasNonce = try await returnGasNonce()
            print("üëÄ gas : \(gasNonce.gas)")
            print("üëÄ nonce : \(gasNonce.nonce)")
            trasaction.transaction.nonce = gasNonce.nonce
            trasaction.transaction.from = accountAddress
            trasaction.transaction.chainID = ChainID
            trasaction.transaction.gasPrice = gasNonce.gas
            let estimatedGasLimit = try await web3.eth.estimateGas(for: trasaction.transaction, onBlock: .pending)
            trasaction.transaction.gasLimit = estimatedGasLimit
            try trasaction.transaction.sign(privateKey: privateKey)
            let result: [String: Any]
            result = try await trasaction.callContractMethod()
            print("‚úÖ Check Result callConfirmReadRecode \(result)")
            return (true,result,gasNonce.nonce)
        }catch let error as TraceUserError{
            throw error
        }catch let error as Web3Error{
            print("‚ùåWeb3Error")
            print(error.errorDescription as Any)
            return (success: false, result: ["":""],nonce: 0)
        }catch{
            print("‚ùå error")
            return (success: false, result: ["":""],nonce: 0)
        }
    }
    
    
    
    
    
    
    
    
    
    //    Ìä∏ÎûúÏ†ùÏÖò Î†àÏãúÌîº ÎåÄÍ∏∞ Î©îÏÑúÎìú 200 Ï¥à ÎèôÏïà ÎåÄÍ∏∞
    private func getTransactionReceipt(transactionHash: Data) async throws -> TransactionReceipt? {
        // ÏòÅÏàòÏ¶ù Ï°∞ÌöåÎ•º ÏúÑÌïú Î∞òÎ≥µ ÏãúÎèÑ
        for _ in 0..<10 {
            if let receipt = try? await web3?.eth.transactionReceipt(transactionHash) {
                return receipt
            }
            // ÏòÅÏàòÏ¶ùÏù¥ ÏïÑÏßÅ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÎã§Î©¥ Ïû†Ïãú ÎåÄÍ∏∞
            try await Task.sleep(nanoseconds: 2_000_000_000) // Ïòà: 2Ï¥à ÎåÄÍ∏∞
        }
        return nil // ÏòÅÏàòÏ¶ùÏùÑ Î∞õÏßÄ Î™ªÌïú Í≤ΩÏö∞
    }
    private func getTransactionReceipt(web3: Web3,transactionHash: Data) async throws -> TransactionReceipt? {
        // ÏòÅÏàòÏ¶ù Ï°∞ÌöåÎ•º ÏúÑÌïú Î∞òÎ≥µ ÏãúÎèÑ
        for _ in 0..<10 {
            if let receipt = try? await web3.eth.transactionReceipt(transactionHash) {
                return receipt
            }
            // ÏòÅÏàòÏ¶ùÏù¥ ÏïÑÏßÅ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÎã§Î©¥ Ïû†Ïãú ÎåÄÍ∏∞
            try await Task.sleep(nanoseconds: 2_000_000_000) // Ïòà: 2Ï¥à ÎåÄÍ∏∞
        }
        return nil // ÏòÅÏàòÏ¶ùÏùÑ Î∞õÏßÄ Î™ªÌïú Í≤ΩÏö∞
    }
    // Í≥µÍ∞úÌÇ§ Ï∂îÏ∂ú
    func GetWalletPublicKey(account: String) throws -> ( isNil: Bool,PublicKey:String) {
        guard let keystoreData = loadFromKeychain(account: account) else {
            print("Failed to load keystore")
            return (true, "")
        }
        guard let keystore = BIP32Keystore(keystoreData)else{
            throw TraceUserError.clientError("")
        }
        guard let accountAddress = keystore.addresses?.first else {
            throw TraceUserError.clientError("")
        }
        print("ÏÇ¨Ïö©Îê† Í≥µÍ∞úÌÇ§ \(accountAddress.address)")
        return (false, accountAddress.address)
    }
    
    func GetWalletPrivateKey(password: String) throws -> Data {
        guard let accountAddress = keystore?.addresses?.first else{
            throw TraceUserError.clientError("")
        }
        do{
            let privateKeyData = try keystore?.UNSAFE_getPrivateKeyData(password: password, account: accountAddress)
            guard let key = privateKeyData else{
                throw TraceUserError.clientError("")
            }
            return key
        }catch{
            throw error
        }
    }
    
    
    
    // Ïä§Ïª® ÏûëÏÑ±Ïãú Nonce Ïù¥ÏÉÅ Î¨∏Ï†ú Ìï¥Í≤∞ÏùÑÏúÑÌïú Îπà Í±∞Îûò ÏÉùÏÑ±
    func sendTransactionEmpty(privateKey: Data) async -> Bool {
        do{
            guard let web3 = web3 else {
                print("‚ùåsendTransactionEmpty web3")
                throw TraceUserError.clientError("")
            }
            guard let accountAddress = accountAddress else{
                print("‚ùåsendTransactionEmpty accountAddress")
                throw TraceUserError.clientError("")
            }
            guard let toAddress = EthereumAddress(try UserVariable.MANAGER_ACCOUNT()) else{
                print("‚ùåsendTransactionEmpty toAddress")
                throw TraceUserError.clientError("")
            }
            let gasNonce = try await returnGasNonce()
            var tx: CodableTransaction = .emptyTransaction
            tx.from = accountAddress
            tx.value = 0
            tx.nonce = gasNonce.nonce
            tx.chainID = ChainID
            tx.to = toAddress
            let estimatedGasLimit = try await web3.eth.estimateGas(for: tx, onBlock: .latest)
            tx.gasLimit = estimatedGasLimit
            try tx.sign(privateKey: privateKey)
            guard let txEncode = tx.encode() else{
                print("‚ùåsendTransactionEmpty txEncode")
                throw TraceUserError.clientError("")
            }
            let result = try await web3.eth.send(raw: txEncode)
            guard let resultData = Data.fromHex(result.hash) else{
                print("‚ùåsendTransactionEmpty resultData \(result)")
                throw TraceUserError.clientError("")
            }
            guard let receipt = try await getTransactionReceipt(transactionHash: resultData) else{
                print("‚ùåsendTransactionEmpty receipt \(result.hash)")
                throw TraceUserError.clientError("")
            }
            print("‚úÖ sendTransactionEmpty \(receipt.logs)")
            return true
        }catch{
            return false
        }
    }
    func callConfirmSaveRecord(key: Data, hospitalID: UInt32, date: BigUInt,password: String) async -> (success:Bool,txHash: String) {
        let maskedValue = hospitalID & 0xFFFFFF
        print( "üí∂ HospitalID \(hospitalID)")
        print( "üí∂ unixTime \(date)")
        guard let keystoreData = loadFromKeychain(account: UserAccount) else {
            print("Failed to load keystore")
            return (false,"")
        }
        
        guard let keystore = BIP32Keystore(keystoreData) else {
            print("keystore ÏÉùÏÑ± Ïã§Ìå®")
            return (false,"")
        }
        let keystoreManager = KeystoreManager([keystore])
        if providerURL == nil{
            return (false, "")
        }
        do {
            let provider = try await Web3HttpProvider(url: providerURL!, network: .Custom(networkID: BigUInt(142537)), keystoreManager: keystoreManager)
            let web3 = Web3(provider: provider)
            
            // keystore Ïóê ÏûàÎäî Í≥ÑÏ†ï Ï£ºÏÜå ÎΩëÏïÑÏò¥
            guard let accountAddress = keystore.addresses?.first else {
                print("Í≥ÑÏ†ï Ï£ºÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
                return (false,"")
            }
            print("üëÄ account : \(accountAddress.address)")
            print("üëÄ Contract : \("0xb397d0C94D920680D73b31c3e0eCb103d909B69a")")
            // abi Í∞í Ï∂îÏ∂ú
            guard let abiUrl = Bundle.main.url(forResource: "PersonalRecords_sol_PersonalRecords", withExtension: "json"),
                  let abiString = try? String(contentsOf: abiUrl) else {
                print("ABI ÌååÏùº Ïã§Ìå®")
                return (false,"")
            }
            let contract = Web3.Contract(web3: web3, abiString: abiString, at: EthereumAddress("0xb397d0C94D920680D73b31c3e0eCb103d909B69a"), abiVersion: 2)
            print("Create Contract")
            // Ìï®Ïàò Ìò∏Ï∂ú Ìä∏ÎûúÏû≠ÏÖò ÏÉùÏÑ±
            guard let transaction = contract?.createWriteOperation(
                "confirmSaveRecord",
                parameters: [maskedValue,date] as [AnyObject],
                extraData: Data()
            ) else {
                print("Ìä∏ÎûúÏû≠ÏÖò ÏÉùÏÑ± Ïã§Ìå®")
                return (false,"")
            }
            print("Create Transaction")
            let maxGasPrice = BigUInt(50) * BigUInt(10).power(9) // Ïòà: 50 Gwei
            let gasPrice = try await web3.eth.gasPrice()
            print("Current gas price (\(gasPrice)) exceeds the configured max gas price (\(maxGasPrice))")
            
            guard gasPrice <= maxGasPrice else {
                print("Current gas price (\(gasPrice)) exceeds the configured max gas price (\(maxGasPrice))")
                return (false,"")
            }
            print("Create Nonce")
            // Ìä∏ÎûúÏû≠ÏÖò ÏÑ§Ï†ï
            let currentNonce = try await web3.eth.getTransactionCount(for: accountAddress, onBlock: .latest)
            let increasedGasPrice = gasPrice * 120 / 100
            
            print("Current nonce: \(currentNonce)")
            transaction.transaction.nonce = currentNonce
            transaction.transaction.from = accountAddress
            transaction.transaction.chainID = ChainID
            transaction.transaction.gasPrice = increasedGasPrice
            print("Current gas price (\(gasPrice)) exceeds the configured max gas price (\(maxGasPrice))")
            let estimatedGasLimit = try await web3.eth.estimateGas(for: transaction.transaction, onBlock: .latest)
            transaction.transaction.gasLimit = estimatedGasLimit
            try! transaction.transaction.sign(privateKey: key)
            let result = try await transaction.writeToChain(password: password, sendRaw: true)
            guard let resultData = Data.fromHex(result.hash) else {
                return (false,"")
            }
            print("Current gas price (\(gasPrice)) exceeds the configured max gas price (\(estimatedGasLimit))")
            do{
                print("Transaction Hash")
                print(result.hash)
                if let receipt = try await getTransactionReceipt(web3: web3, transactionHash: resultData){
                    if let firstLog = receipt.logs.first {
                        print("Address: \(firstLog.address.address)")
                        print("Block Hash: \(firstLog.blockHash.toHexString())")
                        print("Block Number: \(firstLog.blockNumber)")
                        print("Data: \(firstLog.data.toHexString())")
                        let hexString = firstLog.data.toHexString()
                        if let hexValue = BigUInt(hexString, radix: 16) {
                            let decimalValue = String(hexValue)
                            print("16ÏßÑÏàò Í∞í: \(hexString)")
                            print("10ÏßÑÏàò Í∞í: \(decimalValue)")
                        } else {
                            print("ÏûòÎ™ªÎêú 16ÏßÑÏàò Í∞í")
                        }
                        print("Log Index: \(firstLog.logIndex)")
                        print("Removed: \(firstLog.removed)")
                        print("Topics: \(firstLog.topics.map { $0.toHexString()})")
                        print("Transaction Hash: \(firstLog.transactionHash.toHexString())")
                        print("Transaction Index: \(firstLog.transactionIndex)")
                    }
                    return (true,result.hash)
                }else{
                    print("Î†àÏãúÌîºÎ•º Î∞õÏßÄ Î™ªÌï®")
                    return (false,"")
                }
            }
            catch{
                print("receipt \(error.localizedDescription)")
                return (false,"")
            }
        } catch {
            print("Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå® ÏóêÎü¨: \(error.localizedDescription)")
            return (false,"")
        }
    }
    //    Ï†ÄÏû•ÏöîÏ≤≠ Ïª®Ìä∏ÎûôÌä∏ ÏûëÏÑ±
    func callConfirmReqeust(privateKey: Data, hospitalID: UInt32, date: BigUInt, password: String, contractAddress: String) async throws -> (success:Bool,txHash:String) {
        do{
            let result = try await  callConfirmSaveRecode(privateKey: privateKey, hospitalID: hospitalID, date: date, password: password,contractAddress: contractAddress)
            return result
        }catch{
            throw error
        }
    }
    //    ÏàòÏ†ï ÏöîÏ≤≠ Ïª®Ìä∏ÎûôÌä∏ ÏûëÏÑ±
    func callEditSmartContract(privateKey: Data, hospitalID: UInt32, date: BigUInt, index: BigUInt,password: String, contractAddress: String) async  -> (success:Bool,txHash:String){
        
        let result = await callConfirmEditRecord(key: privateKey, contractAddress: contractAddress, hospitalID: hospitalID, date: date, password: password, index: index)
        if result.success{
            return result
        }
        let sendTx = await sendTxForConfirm( key: privateKey)
        if !sendTx{
            return (false,"")
        }
        let result2 = await callConfirmEditRecord(key: privateKey, contractAddress: contractAddress, hospitalID: hospitalID, date: date, password: password, index: index)
        return result2
    }
    
    //    Í≥µÏú†ÏöîÏ≤≠ Ïª®Ìä∏ÎûôÌä∏
    func callShaerReqeust(key: Data, contractAddress: String, param: [SharedData],password: String) async -> (success:Bool,txHash:String) {
        let firstConfirmSave = await setRecordToShareSaveRecord(key: key, contractAddress: contractAddress, param: param, password: password)
        if firstConfirmSave.success{
            return (firstConfirmSave)
        }
        let sendTx = await sendTxForConfirm( key: key)
        if !sendTx{
            return (false,"")
        }
        let secondConfirmSave = await setRecordToShareSaveRecord(key: key, contractAddress: contractAddress, param: param, password: password)
        return secondConfirmSave
    }
    func setRecordToShareSaveRecord(key: Data, contractAddress: String, param: [SharedData], password: String) async -> (success: Bool, txHash: String) {
        guard let keystoreData = loadFromKeychain(account: UserAccount) else {
            print("Failed to load keystore")
            return (false, "")
        }
        
        
        guard let keystore = BIP32Keystore(keystoreData) else {
            print("keystore ÏÉùÏÑ± Ïã§Ìå®")
            return (false, "")
        }
        let keystoreManager = KeystoreManager([keystore])
        if providerURL == nil{
            return (false, "")
        }
        do {
            let provider = try await Web3HttpProvider(url: providerURL!, network: .Custom(networkID: ChainID), keystoreManager: keystoreManager)
            let web3 = Web3(provider: provider)
            
            guard let accountAddress = keystore.addresses?.first else {
                print("Í≥ÑÏ†ï Ï£ºÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
                return (false, "")
            }
            guard let abiUrl = Bundle.main.url(forResource: "PersonalRecords_sol_PersonalRecords", withExtension: "json"),
                  let abiString = try? String(contentsOf: abiUrl) else {
                print("ABI ÌååÏùº Ïã§Ìå®")
                return (false, "")
            }
            let contract = Web3.Contract(web3: web3, abiString: abiString, at: EthereumAddress(contractAddress), abiVersion: 2)
            
            // SharedData Íµ¨Ï°∞Ï≤¥ Î∞∞Ïó¥ÏùÑ Ïä§ÎßàÌä∏ Ïª®Ìä∏ÎûôÌä∏Í∞Ä Í∏∞ÎåÄÌïòÎäî ÌäúÌîå ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
            let paramArray: [[AnyObject]] = param.map { sharedData in
                return [sharedData.index, sharedData.hospital_id, sharedData.hospital_key] as [AnyObject]
            }
            
            guard let transaction = contract?.createWriteOperation(
                "setRecordToShare",
                parameters: [paramArray] as [AnyObject],
                extraData: Data()
            ) else {
                print("Ìä∏ÎûúÏû≠ÏÖò ÏÉùÏÑ± Ïã§Ìå®")
                return (false, "")
            }
            
            let maxGasPrice = BigUInt(50) * BigUInt(10).power(9) // Ïòà: 50 Gwei
            let gasPrice = try await web3.eth.gasPrice()
            
            guard gasPrice <= maxGasPrice else {
                print("Current gas price (\(gasPrice)) exceeds the configured max gas price (\(maxGasPrice))")
                return (false, "")
            }
            
            let currentNonce = try await web3.eth.getTransactionCount(for: accountAddress, onBlock: .latest)
            let increasedGasPrice = gasPrice * 120 / 100
            
            transaction.transaction.nonce = currentNonce
            transaction.transaction.from = accountAddress
            transaction.transaction.chainID = ChainID
            transaction.transaction.gasPrice = increasedGasPrice
            
            let estimatedGasLimit = try await web3.eth.estimateGas(for: transaction.transaction, onBlock: .latest)
            transaction.transaction.gasLimit = estimatedGasLimit
            try transaction.transaction.sign(privateKey: key)
            let result = try await transaction.writeToChain(password: password, sendRaw: true)
            
            guard let resultData = Data.fromHex(result.hash) else {
                return (false, "")
            }
            
            if let receipt = try await getTransactionReceipt(web3: web3, transactionHash: resultData) {
                print("Ìä∏ÎûúÏû≠ÏÖò Î°úÍ∑∏: \(String(describing: receipt.logs))")
                if let firstLog = receipt.logs.first {
                    print("Address: \(firstLog.address.address)")
                    print("Block Hash: \(firstLog.blockHash.toHexString())")
                    print("Block Number: \(firstLog.blockNumber)")
                    print("Data: \(firstLog.data.toHexString())")
                    if let hexValue = BigUInt(firstLog.data.toHexString(), radix: 16) {
                        print("16ÏßÑÏàò Í∞í: \(firstLog.data.toHexString())")
                        print("10ÏßÑÏàò Í∞í: \(String(hexValue))")
                    } else {
                        print("ÏûòÎ™ªÎêú 16ÏßÑÏàò Í∞í")
                    }
                    print("Log Index: \(firstLog.logIndex)")
                    print("Removed: \(firstLog.removed)")
                    print("Topics: \(firstLog.topics.map { $0.toHexString() })")
                    print("Transaction Hash: \(firstLog.transactionHash.toHexString())")
                    print("Transaction Index: \(firstLog.transactionIndex)")
                }
                return (true, result.hash)
            } else {
                print("Î†àÏãúÌîºÎ•º Î∞õÏßÄ Î™ªÌï®")
                return (false, "")
            }
        } catch {
            print("Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå® ÏóêÎü¨: \(error.localizedDescription)")
            return (false, "")
        }
    }
    func sendTxForConfirm(key: Data) async -> Bool {
        
        guard let keystoreData = loadFromKeychain(account: UserAccount) else {
            print("Failed to load keystore")
            return false
        }
        
        if providerURL == nil{
            return false
        }
        guard let keystore = BIP32Keystore(keystoreData) else {
            print("keystore ÏÉùÏÑ± Ïã§Ìå®")
            return false
        }
        let keystoreManager = KeystoreManager([keystore])
        
        do {
            let provider = try await Web3HttpProvider(url: providerURL!, network: .Custom(networkID: ChainID), keystoreManager: keystoreManager)
            let web3 = Web3(provider: provider)
            
            // keystore Ïóê ÏûàÎäî Í≥ÑÏ†ï Ï£ºÏÜå ÎΩëÏïÑÏò¥
            guard let accountAddress = keystore.addresses?.first else {
                print("Í≥ÑÏ†ï Ï£ºÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
                return false
            }
            
            print("Create Nonce")
            // Ìä∏ÎûúÏû≠ÏÖò ÏÑ§Ï†ï
            let currentNonce = try await web3.eth.getTransactionCount(for: accountAddress, onBlock: .latest)
            
            let tos = "0x1099530d4F290CcAb9bcdfb059CFF84922827526"
            var tx: CodableTransaction = .emptyTransaction
            tx.from = accountAddress
            tx.value = 0
            tx.nonce = currentNonce
            tx.gasLimit = BigUInt(21000)// Í∏∞Î≥∏ Í∞ÄÏä§ ÌïúÎèÑ (ÌïÑÏöî Ïãú Ï°∞Ï†ï)
            tx.gasPrice = BigUInt(2000000000)
            tx.chainID = ChainID
            guard let toAddress = EthereumAddress(tos) else {
                print("Invalid 'to' address")
                return false
            }
            tx.to = toAddress
            try tx.sign(privateKey: key)
            print("Í∞úÏù∏ÌÇ§ Îç∞Ïù¥ÌÑ∞ Í∏∏Ïù¥: \(key.count) Î∞îÏù¥Ìä∏")
            guard let transactionEncode = tx.encode() else{
                print("Ìä∏Î†åÏ†ùÏÖò Ïù∏ÏΩîÎî© Ïã§Ìå®")
                return false
            }
            
            let result = try await web3.eth.send(raw: transactionEncode)
            guard let resultData = Data.fromHex(result.hash) else{
                return false
            }
            do{
                print("Transaction Hash")
                print(result.hash)
                if let receipt = try await getTransactionReceipt(web3: web3, transactionHash: resultData){
                    print("Ìä∏ÎûúÏû≠ÏÖò Î°úÍ∑∏: \(String(describing: receipt.logs))")
                    return true
                }else{
                    print("Î†àÏãúÌîºÎ•º Î∞õÏßÄ Î™ªÌï®")
                    return false
                }
            }
            catch{
                print("receipt \(error.localizedDescription)")
                return false
            }
        } catch {
            print("Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå® ÏóêÎü¨: \(error.localizedDescription)")
            return false
        }
    }
}
